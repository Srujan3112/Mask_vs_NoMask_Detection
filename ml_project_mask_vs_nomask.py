# -*- coding: utf-8 -*-
"""ML_Project_mask_vs_nomask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dNj5DFXBFdq9oWDAzubidb5XMoLAJGBP
"""

# Importing the required libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, classification_report
import seaborn as sns
from sklearn.metrics import f1_score,accuracy_score
import os,zipfile,cv2
from google.colab.patches import cv2_imshow

# for extracting rar files
!pip install rarfile 
import rarfile



"""EXtracting zip files"""

z = zipfile.ZipFile('/content/drive/MyDrive/self-built-masked-face-recognition-dataset.zip') # self_build masked dataset unzipping

z.extractall('.')

z=zipfile.ZipFile('/content/drive/MyDrive/Real-World-Masked-Face-Dataset-master.zip')  # Real_world masked dataset unzipping

z.extractall('.')

#displaying the image in AFDB face dataset

cv2_imshow(cv2.imread('/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset/aidai/'+os.listdir('/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset/aidai')[7]))

#displaying the image in masked dataset

cv2_imshow(cv2.imread('/content/self-built-masked-face-recognition-dataset/AFDB_masked_face_dataset/aidai/'+os.listdir('/content/self-built-masked-face-recognition-dataset/AFDB_masked_face_dataset/aidai')[0]))

"""Extract the images present in different subfolders folder and place them in one folder and deleting the subfolders."""

import shutil
folder1 = '/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset'

subf = [f.path for f in os.scandir(folder1) if f.is_dir()]

for sub in subf:
    for f in os.listdir(sub):
        src = os.path.join(sub, f)
        dst = os.path.join(folder1, f)
        shutil.move(src, dst)
    shutil.rmtree(sub)

folder2 = '/content/self-built-masked-face-recognition-dataset/AFDB_masked_face_dataset'

subf2 = [f.path for f in os.scandir(folder2) if f.is_dir()]

for sub in subf2:
    for f in os.listdir(sub):
        src = os.path.join(sub, f)
        dst = os.path.join(folder2, f)
        shutil.move(src, dst)
    shutil.rmtree(sub)

folder3 = '/content/Real-World-Masked-Face-Dataset-master/RWMFD_part_1'
subf3 = [f.path for f in os.scandir(folder3) if f.is_dir()]
for sub in subf3:
    for f in os.listdir(sub):
        src = os.path.join(sub, f)
        dst = os.path.join(folder3, f)
        shutil.move(src, dst)
    shutil.rmtree(sub)

cv2_imshow(cv2.imread('/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset/'+os.listdir('/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset')[1000]))

cv2_imshow(cv2.imread('/content/self-built-masked-face-recognition-dataset/AFDB_masked_face_dataset/'+os.listdir('/content/self-built-masked-face-recognition-dataset/AFDB_masked_face_dataset')[10]))

# sample image
img = cv2.imread('/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset/0_0_aidai_0014.jpg')

img.shape # dimensions of the image

cv2_imshow(img)  # sample image with no mask

X_without_mask = [] # In this we append the images with no mask
y = []  # store the corresponding labels of images. It is 0 represnting without mask and 1 for Masked images

#this code snippet iterates over the folder given by path and reads all the images present in it and append their corresponding labels
path = '/content/self-built-masked-face-recognition-dataset/AFDB_face_dataset'
for i in os.listdir(path):
  loc = os.path.join(path,i)
  image = cv2.imread(loc)
  image_reshaped = cv2.resize(image,(28,28))
  X_without_mask.append(image_reshaped)
  y.append(0)

X_masked = []  # It will hold all the images with mask

#this code snippet iterates over the folder given by path and reads all the images present in it and append their corresponding labels
path = '/content/self-built-masked-face-recognition-dataset/AFDB_masked_face_dataset'
for i in os.listdir(path):
  loc = os.path.join(path,i)
  image = cv2.imread(loc)
  image_reshaped = cv2.resize(image,(28,28))
  X_masked.append(image_reshaped)
  y.append(1)

len(X_masked)



#this code snippet iterates over the folder given by path and reads all the images present in it and append their corresponding labels
path = '/content/Real-World-Masked-Face-Dataset-master/RWMFD_part_1'
for i in os.listdir(path):
  loc = os.path.join(path,i)
  image = cv2.imread(loc)
  image_reshaped = cv2.resize(image,(28,28))
  X_masked.append(image_reshaped)
  y.append(1)

len(X_masked)

# Unraring files in Real world dataset

def unrar(dpath,xpath):
    filepath = dpath
    with rarfile.RarFile(filepath) as opened_rar:
      for f in opened_rar.infolist():
        print (f.filename, f.file_size)
        opened_rar.extractall(xpath)

dpath = '/content/Real-World-Masked-Face-Dataset-master/RMFD_part_2.part1.rar' # location of folder which is to be unrar
xpath = '/content/Real-World-Masked-Face-Dataset-master'  # location where to extract

unrar(dpath,xpath)



# the following code snippet extract images from subfolder and place them in superfolder.

folder4 = '/content/Real-World-Masked-Face-Dataset-master/RWMFD_part_2_pro'
subf4 = [f.path for f in os.scandir(folder4) if f.is_dir()]
for sub in subf4:
    for f in os.listdir(sub):
        src = os.path.join(sub, f)
        dst = os.path.join(folder4, f)
        shutil.move(src, dst)
    shutil.rmtree(sub)    # delete the subfolder

img = cv2.imread('/content/Real-World-Masked-Face-Dataset-master/RWMFD_part_2_pro/034.jpg') # sample image

cv2_imshow(img) #sample image

#this code snippet iterates over the folder given by path and reads all the images present in it and append their corresponding labels
path = '/content/Real-World-Masked-Face-Dataset-master/RWMFD_part_2_pro'
for i in os.listdir(path):
  loc = os.path.join(path,i)
  image = cv2.imread(loc)
  image_reshaped = cv2.resize(image,(28,28))
  X_masked.append(image_reshaped)
  y.append(1)

len(X_masked)



# converting the list into numpy array 
X_without_mask = np.array(X_without_mask)
X_masked = np.array(X_masked)



X_without_mask.shape[0]

# Reshaping the masked and without masked data from 4-dimension to 2 dimension.
X_without_mask = X_without_mask.reshape(X_without_mask.shape[0],28*28*3)
X_masked = X_masked.reshape(X_masked.shape[0],28*28*3)

print(X_without_mask.shape)
print(X_masked.shape)

X = np.r_[X_without_mask,X_masked] # appending complete data row by row into new array X

X.shape

df = pd.DataFrame(X)

df.head()

df2 = pd.DataFrame(y)

df2.head()

df_final = pd.concat([df,df2],axis=1)

df_final.tail()

# Splitting the data into equal ratio for training and testing
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y,stratify=y,test_size=0.5,random_state=0)

print("X_train",X_train.shape)
print("X_test",X_test.shape)

"""Training the machine learning models

1. SVM
"""

from sklearn.svm import SVC
svc_lin = SVC(kernel='linear',class_weight='balanced')

svc_lin.fit(X_train,y_train)

y_pred = svc_lin.predict(X_test)

"""Accuracy and F1_score for svm"""

print("F1_score",f1_score(y_true=y_test,y_pred=y_pred))
print("Accuracy",accuracy_score(y_test,y_pred))

svc_rbf = SVC(kernel='rbf',class_weight='balanced')

svc_rbf.fit(X_train,y_train)

y_pred = svc_rbf.predict(X_test)

print("F1_score",f1_score(y_true=y_test,y_pred=y_pred))
print("Accuracy",accuracy_score(y_test,y_pred))

"""2. Logistice Regression"""

from sklearn.linear_model import LogisticRegression

lg = LogisticRegression(max_iter=10000,class_weight='balanced')
lg.fit(X_train,y_train)

y_pred = lg.predict(X_test)

print("F1_score",f1_score(y_true=y_test,y_pred=y_pred))
print("Accuracy",accuracy_score(y_test,y_pred))

"""3. MLP"""

from sklearn.neural_network import MLPClassifier

mlp = MLPClassifier(hidden_layer_sizes=1570)   # size of hidden kayers = 2/3*(input_layer)+output_layer

mlp.fit(X_train,y_train)

y_pred = mlp.predict(X_test)

print("F1_score",f1_score(y_true=y_test,y_pred=y_pred))
print("Accuracy",accuracy_score(y_test,y_pred))

"""Applying cross validation"""

from sklearn.model_selection import StratifiedKFold

# stratified kfold maintains similar disrtibution in training and testing data
skf = StratifiedKFold(n_splits=3, shuffle=True, random_state=1)
l = []

y_np = np.array(y)

for train_index, test_index in skf.split(X, y):
    x_train_fold, x_test_fold = X[train_index], X[test_index]
    y_train_fold, y_test_fold = y_np[train_index], y_np[test_index]
    lg.fit(x_train_fold, y_train_fold)
    y_fold_pred = lg.predict(x_test_fold)
    l.append(f1_score(y_fold_pred, y_test_fold))

from statistics import mean
print('List of possible F1score:', l)
print('\nMaximum F1score That can be obtained from this model is:',
      max(l)*100, '%')
print('\nMinimum F1score:',
      min(l)*100, '%')
print('\nOverall F1score:',
      mean(l)*100, '%')